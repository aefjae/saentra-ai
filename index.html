const { setMemory, getMemory, getAllMemory, saveChatMessage, getRecentHistory } = require('./database')
const { app, BrowserWindow, globalShortcut, ipcMain, screen, desktopCapturer } = require('electron')
const path = require('path')
const https = require('https')
const dns = require('dns')

dns.setDefaultResultOrder('ipv4first')

let overlayWindow = null

const BACKEND_URL = 'https://nalar-backend-production.up.railway.app'

function createOverlay() {
  const { width, height } = screen.getPrimaryDisplay().workAreaSize

  overlayWindow = new BrowserWindow({
    width: 420,
    height: 600,
    x: width - 440,
    y: height - 630,
    frame: false,
    transparent: true,
    alwaysOnTop: true,
    skipTaskbar: true,
    resizable: true,
    hasShadow: true,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    }
  })

  overlayWindow.loadFile(path.join(__dirname, '../renderer/index.html'))
  overlayWindow.setVisibleOnAllWorkspaces(true, { visibleOnFullScreen: false })
  overlayWindow.show()
}

async function takeScreenshot() {
  const sources = await desktopCapturer.getSources({
    types: ['screen'],
    thumbnailSize: { width: 1920, height: 1080 }
  })
  if (sources.length === 0) return null
  return sources[0].thumbnail.toJPEG(85).toString('base64')
}

function httpPost(url, data) {
  return new Promise((resolve, reject) => {
    const body = JSON.stringify(data)
    const urlObj = new URL(url)
    const options = {
      hostname: urlObj.hostname,
      path: urlObj.pathname,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(body)
      },
      timeout: 30000
    }

    const req = https.request(options, (res) => {
      let responseData = ''
      res.on('data', chunk => responseData += chunk)
      res.on('end', () => {
        try { resolve(JSON.parse(responseData)) }
        catch (e) { reject(new Error('Invalid JSON response')) }
      })
    })

    req.on('error', reject)
    req.on('timeout', () => {
      req.destroy()
      reject(new Error('Request timeout'))
    })
    req.write(body)
    req.end()
  })
}

async function askNalar(question, screenshotBase64, chatHistory) {
  // Ambil semua memory user
  const memories = getAllMemory()
  const memoryContext = memories.length > 0
    ? '\n\nAPA YANG KAMU TAU TENTANG USER INI:\n' +
      memories.map(m => `- ${m.key}: ${m.value}`).join('\n')
    : ''

  // Retry logic untuk handle Overloaded / 529 dari Anthropic
  const maxRetries = 3
  let lastError
  let data

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      data = await httpPost(`${BACKEND_URL}/ask`, {
        question,
        screenshot: screenshotBase64,
        chatHistory: chatHistory.slice(-6),
        memoryContext
      })
      break // sukses, keluar dari loop
    } catch (err) {
      lastError = err
      const isOverloaded = err.message?.includes('Overloaded') || err.message?.includes('529') || err.message?.includes('503')
      if (isOverloaded && attempt < maxRetries - 1) {
        const waitMs = (attempt + 1) * 2000 // 2s, 4s
        console.log(`â³ API overloaded, retry ${attempt + 1}/${maxRetries - 1} dalam ${waitMs / 1000}s...`)
        await new Promise(r => setTimeout(r, waitMs))
        continue
      }
      throw err
    }
  }

  if (!data) throw lastError
  if (!data.success) {
    const isOverloaded = data.answer?.includes('Overloaded') || data.answer?.includes('overloaded')
    if (isOverloaded) throw new Error('Overloaded')
    throw new Error(data.answer)
  }

  // Simpan percakapan ke history
  saveChatMessage('user', question)
  saveChatMessage('assistant', data.answer)

  // Extract dan simpan memory (silent â€” ga ganggu flow utama)
  try {
    const conversation = `User: ${question}\nSaentra: ${data.answer}`
    const memoryData = await httpPost(`${BACKEND_URL}/extract-memory`, { conversation })
    if (memoryData.memories && memoryData.memories.length > 0) {
      memoryData.memories.forEach(({ key, value }) => {
        if (key && value) {
          setMemory(key, value)
          console.log(`ðŸ’¾ Memory saved: ${key} = ${value}`)
        }
      })
    }
  } catch (err) {
    console.log('Memory extract skip:', err.message)
  }

  return data.answer
}

ipcMain.handle('take-screenshot', async () => {
  overlayWindow.hide()
  await new Promise(r => setTimeout(r, 200))
  const screenshot = await takeScreenshot()
  overlayWindow.show()
  return screenshot
})

ipcMain.handle('ask-claude', async (event, { question, screenshot, chatHistory }) => {
  try {
    const answer = await askNalar(question, screenshot, chatHistory)
    return { success: true, answer }
  } catch (err) {
    console.error('Nalar error:', err)
    const isOverloaded = err.message?.includes('Overloaded') || err.message?.includes('overloaded')
    const userMessage = isOverloaded
      ? 'Server AI lagi sibuk, sudah dicoba 3x. Tunggu sebentar lalu coba lagi ya ðŸ™'
      : `Error: ${err.message}`
    return { success: false, answer: userMessage }
  }
})

ipcMain.handle('toggle-window', () => {
  if (overlayWindow.isVisible()) {
    overlayWindow.hide()
  } else {
    overlayWindow.show()
    overlayWindow.focus()
  }
})

app.whenReady().then(() => {
  app.setLoginItemSettings({ openAtLogin: true })
  createOverlay()

  const hotkey = process.platform === 'darwin' ? 'Cmd+Shift+Space' : 'Ctrl+Shift+Space'
  globalShortcut.register(hotkey, () => {
    if (overlayWindow.isVisible()) {
      overlayWindow.hide()
    } else {
      overlayWindow.show()
      overlayWindow.focus()
    }
  })

  console.log(`âœ… Saentra AI aktif! Tekan ${hotkey} untuk toggle`)
})

app.on('will-quit', () => globalShortcut.unregisterAll())
app.on('window-all-closed', () => { if (process.platform !== 'darwin') app.quit() })
